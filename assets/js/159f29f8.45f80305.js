"use strict";(self.webpackChunkcommunity_docs=self.webpackChunkcommunity_docs||[]).push([[2614],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=o.createContext({}),l=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=l(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),h=l(n),p=i,f=h["".concat(s,".").concat(p)]||h[p]||u[p]||a;return n?o.createElement(f,r(r({ref:t},d),{},{components:n})):o.createElement(f,r({ref:t},d))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,r[1]=c;for(var l=2;l<a;l++)r[l]=n[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5226:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var o=n(7462),i=(n(7294),n(3905));const a={},r="Client Theory",c={unversionedId:"mainnet/complete-node-guide/blockchain-clients/client-theory",id:"mainnet/complete-node-guide/blockchain-clients/client-theory",title:"Client Theory",description:"When engaging with blockchain technologies, it's crucial to understand the different types of software clients involved in the process. The interplay between these clients makes a blockchain network function as intended, and understanding their roles and functionalities can help users troubleshoot issues and optimize their experiences.",source:"@site/docs/mainnet/complete-node-guide/6-blockchain-clients/03-client-theory.md",sourceDirName:"mainnet/complete-node-guide/6-blockchain-clients",slug:"/mainnet/complete-node-guide/blockchain-clients/client-theory",permalink:"/docs/mainnet/complete-node-guide/blockchain-clients/client-theory",draft:!1,editUrl:"https://github.com/Luksoverse/community-docs/tree/main/packages/create-docusaurus/templates/shared/docs/mainnet/complete-node-guide/6-blockchain-clients/03-client-theory.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Network Theory",permalink:"/docs/mainnet/complete-node-guide/blockchain-clients/network-theory"},next:{title:"Client Setups",permalink:"/docs/mainnet/complete-node-guide/blockchain-clients/client-setups"}},s={},l=[{value:"6.3.1 Execution Client",id:"631-execution-client",level:3},{value:"6.3.2 Consensus Client",id:"632-consensus-client",level:3},{value:"6.3.3 Validator Client",id:"633-validator-client",level:3}],d={toc:l};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"client-theory"},"Client Theory"),(0,i.kt)("p",null,"When engaging with blockchain technologies, it's crucial to understand the different types of software clients involved in the process. The interplay between these clients makes a blockchain network function as intended, and understanding their roles and functionalities can help users troubleshoot issues and optimize their experiences."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"You will have to run all 3 clients to become a validator. However, you can also run the setup without the validator client if you want to participate and store the network without gaining returns.")),(0,i.kt)("h3",{id:"631-execution-client"},"6.3.1 Execution Client"),(0,i.kt)("p",null,"The Execution Client, also referred to as blockchain or network client, is the software that directly interacts with the blockchain. It connects to the blockchain network, downloads and verifies blocks, maintains a local copy of the blockchain data, and propagates transactions and blocks."),(0,i.kt)("p",null,"Underneath, the Execution Client does a lot of heavy lifting: it verifies cryptographic proofs, validates transactions, applies state changes, manages the local database, and provides an interface for querying and spreading the blockchain data from or to other nodes. Regarding the copy of the blockchain data, it maintains account balances, contract bytecode, contract storage, and the transaction pool."),(0,i.kt)("p",null,"The transaction pool, often called the memory pool, is a set of transactions broadcast to the network but not yet included in a block. The execution client is responsible for managing this pool, deciding which transactions to fit in a proposed block based on criteria such as gas price, and executing these transactions when they are included."),(0,i.kt)("p",null,"The execution client also communicates with the consensus client to receive updates on the state of the consensus protocol, including finalized blocks and the current state of the validator set."),(0,i.kt)("h3",{id:"632-consensus-client"},"6.3.2 Consensus Client"),(0,i.kt)("p",null,"The consensus client, also referred to as the beacon client or beacon node, is responsible for participating in the consensus protocol of the blockchain. In a Proof of Stake system, this involves proposing own blocks and attesting to the validity of proposed blocks."),(0,i.kt)("p",null,"Under the hood, the Consensus Client communicates with other validators to agree on the state of the blockchain. It signs messages with the validator's private key as part of the consensus process and reads from and writes to the blockchain through the execution client."),(0,i.kt)("h3",{id:"633-validator-client"},"6.3.3 Validator Client"),(0,i.kt)("p",null,"The Validator Client is often a part of the Consensus Client software. It manages the validator's keypairs and performs the duties assigned by the consensus protocol: proposing blocks and making attestations."),(0,i.kt)("p",null,"The validator client only manages the validator's activities, while the consensus client implements the consensus protocol and communicates with the rest of the network."))}u.isMDXComponent=!0}}]);